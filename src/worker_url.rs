//! [`Url`] used when spawning a worker.
//!
//! Usually initializing a worker requires a JS script to be executed, we
//! generate one on the fly to minimize any configuration the user would
//! otherwise have to do to serve that JS script.

use std::ops::Deref;

use js_sys::Array;
use wasm_bindgen::JsValue;
use web_sys::{console, Blob, BlobPropertyBag, Url};

thread_local! {
	/// All workers are spawned from the window only, so having this thread-local is enough.
	pub(crate) static WORKER_URL: WorkerUrl = WorkerUrl::new();
}

/// Holds the worker [`Url`]. This is important so it's deallocated when we are
/// done.
pub(crate) struct WorkerUrl(String);

impl Deref for WorkerUrl {
	type Target = str;

	fn deref(&self) -> &Self::Target {
		&self.0
	}
}

impl Drop for WorkerUrl {
	fn drop(&mut self) {
		if let Err(error) = Url::revoke_object_url(&self.0) {
			// Avoid panicking in a `Drop` implementation.
			console::warn_1(&format!("worker `Url` could not be deallocated: {error:?}").into());
		}
	}
}

impl WorkerUrl {
	/// Creates a new [`WorkerUrl`].
	fn new() -> Self {
		// Put together the JS shim running on the worker.
		// Import the JS shim generated by `wasm-bindgen`.
		let header = format!("importScripts('{}');\n", wasm_bindgen::script_url());
		// Add the worker JS shim, receiving the WASM module and starting the worker.
		let script = include_str!("web_worker.js");

		// Create the `Blob` necessary to create the worker `Url`.
		let sequence = Array::of2(&JsValue::from(header.as_str()), &JsValue::from(script));
		let mut property = BlobPropertyBag::new();
		property.type_("text/javascript");
		let blob = Blob::new_with_str_sequence_and_options(&sequence, &property);

		// Create the `Url` for the worker.
		// `URL.createObjectURL()` should only fail on unsupported `Blob`s, this is
		// consistent and is caught during testing.
		let url = blob
			.and_then(|blob| Url::create_object_url_with_blob(&blob))
			.expect("worker `Url` could not be created");

		Self(url)
	}
}
